<script lang="ts">
  import { onMount } from 'svelte';
  import CodeBlock from './CodeBlock.svelte';
  
  interface Props {
    sectionId?: string;
    compact?: boolean;
  }
  
  let { sectionId, compact = false }: Props = $props();
  
  const examples = [
    {
      name: 'Instant pass (httpbin)',
      prompt: `Create a single story that verifies API health.
Use API_URL + "/status/200" for the HTTP observe.
Assert success using the http log status and Assert.noErrors().`
    },
    {
      name: 'Simple API Health Check',
      prompt: `API responds without errors
API returns 200 status code`
    },
    {
      name: 'User Signup Flow',
      prompt: `User can sign up
User receives verification email (depends on signup)
User can log in after verification (depends on email verification)`
    },
    {
      name: 'E-commerce Checkout',
      prompt: `Product page loads
Add to cart works
Checkout process completes
Payment is processed (depends on checkout)
Order confirmation email sent (depends on payment)`
    },
    {
      name: 'API Integration',
      prompt: `External API connection established
Data is fetched successfully
Data is transformed correctly
Transformed data is saved to database (depends on data transformation)`
    },
    {
      name: 'Authentication Flow',
      prompt: `User can register
User can log in
User session is created (depends on login)
Protected route requires authentication (depends on session)
User can log out`
    }
  ];
  
  const defaultPrompt = examples[0]?.prompt ?? '';
  let descriptions = $state(defaultPrompt);
  let loading = $state(false);
  let generatedCode = $state<string | null>(null);
  let error = $state<string | null>(null);
  let running = $state(false);
  let runError = $state<string | null>(null);
  let runLogs = $state<string[]>([]);
  let apiUrl = $state('https://httpbin.org');
  let testUrl = $state('https://example.com');
  let runStartedAt = $state<number | null>(null);
  let elapsedMs = $state(0);
  let timer: ReturnType<typeof setInterval> | null = null;
  let runMeta = $state<{ sandboxId?: string; processId?: string } | null>(null);
  let gateFiles = $state<Array<{ id: string; filename: string; code: string }>>([]);
  let gateError = $state<string | null>(null);
  const exampleList = $derived(compact ? examples.slice(0, 3) : examples);
  let autoGenerated = $state(false);
  
  async function generatePrd() {
    if (!descriptions.trim()) {
      error = 'Please enter story descriptions';
      return;
    }
    
    loading = true;
    error = null;
    generatedCode = null;
    gateFiles = [];
    gateError = null;
    
    try {
      const response = await fetch('/api/prd/generate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ descriptions }),
      });
      
      const data = (await response.json()) as {
        success?: boolean;
        prdFile?: string;
        error?: string;
        message?: string;
      };
      
      if (!response.ok) {
        error = data.message || data.error || 'Failed to generate PRD';
        return;
      }
      
      if (data.prdFile) {
        generatedCode = data.prdFile;
      } else {
        error = 'No PRD file generated';
      }
    } catch (err) {
      error = err instanceof Error ? err.message : 'Unknown error occurred';
    } finally {
      loading = false;
    }
  }

  // onMount(() => {
  //   if (compact && descriptions.trim() && !autoGenerated) {
  //     autoGenerated = true;
  //     void generatePrd();
  //   }
  // });
  
  function copyToClipboard() {
    if (!generatedCode) return;
    
    navigator.clipboard.writeText(generatedCode).then(() => {
      // Simple feedback - could enhance with toast
      const button = document.querySelector('[data-copy-btn]') as HTMLButtonElement;
      if (button) {
        const originalText = button.textContent;
        button.textContent = 'Copied!';
        setTimeout(() => {
          button.textContent = originalText;
        }, 2000);
      }
    }).catch(() => {
      error = 'Failed to copy to clipboard';
    });
  }
  
  function downloadPrd() {
    if (!generatedCode) return;
    
    const blob = new Blob([generatedCode], { type: 'text/typescript' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'prd.ts';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  function extractGateFiles(prdFile: string): Array<{ id: string; filename: string; code: string }> {
    const importsMatch = prdFile.match(/import\s+\{[^}]+\}\s+from\s+["']gateproof["'];/);
    const importLine = importsMatch?.[0] ?? `import { Gate, Act, Assert } from "gateproof";`;

    const gateMapRegex = /"([^"]+)":\s*([A-Za-z0-9_]+)Gate/g;
    const gateMap = new Map<string, string>();
    let mapMatch: RegExpExecArray | null;
    while ((mapMatch = gateMapRegex.exec(prdFile))) {
      gateMap.set(mapMatch[1], `${mapMatch[2]}Gate`);
    }

    const functionRegex = /function\s+([A-Za-z0-9_]+Gate)\s*\(\)\s*\{/g;
    const functions = new Map<string, string>();
    let match: RegExpExecArray | null;
    while ((match = functionRegex.exec(prdFile))) {
      const functionName = match[1];
      const braceStart = prdFile.indexOf("{", match.index);
      if (braceStart === -1) continue;
      let depth = 1;
      let i = braceStart + 1;
      while (i < prdFile.length && depth > 0) {
        const char = prdFile[i];
        if (char === "{") depth += 1;
        if (char === "}") depth -= 1;
        i += 1;
      }
      const functionBlock = prdFile.slice(match.index, i);
      functions.set(functionName, functionBlock);
    }

    const files: Array<{ id: string; filename: string; code: string }> = [];
    for (const [id, functionName] of gateMap) {
      const functionBlock = functions.get(functionName);
      if (!functionBlock) continue;

      const commentIndex = prdFile.lastIndexOf("// Gate:", prdFile.indexOf(functionBlock));
      let commentLine = "";
      if (commentIndex !== -1) {
        const lineStart = prdFile.lastIndexOf("\n", commentIndex) + 1;
        const lineEnd = prdFile.indexOf("\n", commentIndex);
        const candidate = prdFile.slice(lineStart, lineEnd === -1 ? prdFile.length : lineEnd);
        const between = prdFile.slice(lineEnd === -1 ? prdFile.length : lineEnd, prdFile.indexOf(functionBlock));
        if (between.trim().length === 0) {
          commentLine = candidate;
        }
      }

      const normalized = functionBlock.replace(
        new RegExp(`function\\s+${functionName}\\s*\\(\\)`),
        "export function run()"
      );

      const code = `${importLine}\n\n${commentLine ? `${commentLine}\n` : ""}${normalized}\n`;
      files.push({
        id,
        filename: `gates/${id}.gate.ts`,
        code,
      });
    }

    return files;
  }

  function generateGates() {
    if (!generatedCode) return;
    gateError = null;
    try {
      const files = extractGateFiles(generatedCode);
      if (files.length === 0) {
        gateError = "Could not find gate implementations in the PRD output.";
        gateFiles = [];
        return;
      }
      gateFiles = files;
    } catch (err) {
      gateError = err instanceof Error ? err.message : "Failed to extract gates";
    }
  }

  function copyGateFile(filename: string, code: string) {
    navigator.clipboard.writeText(code).catch(() => {
      gateError = `Failed to copy ${filename}`;
    });
  }

  function downloadGateFile(filename: string, code: string) {
    const blob = new Blob([code], { type: "text/typescript" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename.split("/").pop() || "gate.ts";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  async function runInSandbox() {
    if (!generatedCode) return;
    running = true;
    runError = null;
    runLogs = [];
    runMeta = null;
    runStartedAt = Date.now();
    elapsedMs = 0;
    if (timer) clearInterval(timer);
    timer = setInterval(() => {
      if (runStartedAt) elapsedMs = Date.now() - runStartedAt;
    }, 500);

    try {
      const response = await fetch('/api/prd/run', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          prdFile: generatedCode,
          apiUrl,
          testUrl
        })
      });

      if (!response.ok || !response.body) {
        const text = await response.text();
        throw new Error(text || 'Failed to start sandbox run');
      }

      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let buffer = '';

      while (true) {
        const { value, done } = await reader.read();
        if (done) break;
        buffer += decoder.decode(value, { stream: true });

        let chunkEnd = buffer.indexOf('\n\n');
        while (chunkEnd !== -1) {
          const chunk = buffer.slice(0, chunkEnd).trim();
          buffer = buffer.slice(chunkEnd + 2);
          chunkEnd = buffer.indexOf('\n\n');

          if (!chunk) continue;
          const lines = chunk.split('\n');
          let eventType = 'message';
          let dataPayload = '';
          for (const line of lines) {
            if (line.startsWith('event:')) {
              eventType = line.replace('event:', '').trim();
            } else if (line.startsWith('data:')) {
              dataPayload += line.replace('data:', '').trim();
            }
          }

          if (!dataPayload) continue;
          try {
            const data = JSON.parse(dataPayload);
            if (eventType === 'meta') {
              runMeta = { sandboxId: data.sandboxId, processId: data.processId };
            } else if (eventType === 'stdout' || eventType === 'stderr') {
              runLogs = [...runLogs, data.data];
            } else if (eventType === 'complete') {
              const statusLabel = data.exitCode != null ? `exit ${data.exitCode}` : data.status;
              runLogs = [...runLogs, `\n[${statusLabel}]`];
            } else if (eventType === 'error') {
              runError = data.error || 'Sandbox execution failed';
            }
          } catch {
            runLogs = [...runLogs, dataPayload];
          }
        }
      }
    } catch (err) {
      runError = err instanceof Error ? err.message : 'Unknown error occurred';
    } finally {
      running = false;
      runStartedAt = null;
      if (timer) {
        clearInterval(timer);
        timer = null;
      }
    }
  }

  async function cancelRun() {
    if (!runMeta?.sandboxId || !runMeta?.processId) return;
    try {
      await fetch('/api/prd/run/stop', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(runMeta)
      });
      runLogs = [...runLogs, '\n[run cancelled]'];
    } catch (err) {
      runError = err instanceof Error ? err.message : 'Failed to cancel run';
    }
  }
</script>

<section id={sectionId} class={`relative flex items-center justify-center px-4 sm:px-8 ${compact ? 'py-6' : 'py-40'}`}>
  <div class="relative z-10 w-full max-w-5xl mx-auto">
    {#if !compact}
      <h2 class="text-4xl sm:text-5xl md:text-6xl font-bold text-center mb-4 text-white">
        <span class="text-amber-300">PRD</span> Builder
      </h2>
      
      <p class="text-center text-lg sm:text-xl text-white/80 mb-8 max-w-2xl mx-auto text-balance">
        Paste a prompt. It becomes a typed PRD and runnable gates.
      </p>
    {:else}
      <div class="mb-4 flex items-center justify-between text-xs uppercase tracking-[0.2em] text-white/60">
        <span>Prompt → PRD → Gates</span>
        <span class="text-amber-200/80">Live</span>
      </div>
    {/if}
    
    <div class={`bg-black/40 backdrop-blur-sm border border-white/10 rounded-lg ${compact ? 'p-4' : 'p-6'} mb-6`}>
      <div class="mb-4">
        <div class="block text-xs font-semibold text-white/80 mb-2">
          Try an example
        </div>
        <div class="flex flex-wrap gap-2">
          {#each exampleList as example}
            <button
              onclick={() => { descriptions = example.prompt; }}
              class="px-3 py-1.5 text-xs bg-white/5 hover:bg-white/10 border border-white/10 hover:border-amber-300/30 text-white rounded transition-colors"
            >
              {example.name}
            </button>
          {/each}
        </div>
      </div>
      
      <label for="descriptions" class="block text-sm font-semibold text-white mb-2">
        Prompt
      </label>
      <textarea
        id="descriptions"
        bind:value={descriptions}
        placeholder="Build a signup flow with email verification and login. Add a health check story for the API."
        class={`w-full ${compact ? 'h-28' : 'h-32'} px-4 py-3 bg-black/60 border border-white/20 rounded-lg text-white placeholder:text-white/40 focus:outline-none focus:border-amber-300/50 focus:ring-2 focus:ring-amber-300/20 resize-none font-mono text-sm`}
        disabled={loading}
      ></textarea>
      {#if !compact}
        <p class="text-xs text-white/60 mt-2">
          Paste a prompt. The generator infers stories, dependencies, and gates.
        </p>
      {/if}
    </div>
    
    <div class="flex justify-center mb-6">
      <button
        onclick={generatePrd}
        disabled={loading || !descriptions.trim()}
        class="px-8 py-3 bg-amber-500 hover:bg-amber-600 disabled:bg-gray-600 disabled:cursor-not-allowed text-white font-medium rounded-lg transition-colors"
      >
        {#if loading}
          Generating...
        {:else}
          Generate PRD
        {/if}
      </button>
    </div>
    
    {#if error}
      <div class="bg-red-900/30 border border-red-500/50 rounded-lg p-4 mb-6">
        <p class="text-red-200 text-sm">{error}</p>
      </div>
    {/if}
    
    {#if generatedCode}
      <div class="bg-black/60 backdrop-blur-sm border border-amber-300/30 rounded-lg shadow-xl overflow-hidden">
        <div class="bg-gray-900/80 px-4 py-3 flex items-center justify-between border-b border-white/10">
          <p class="text-sm font-semibold text-white">Generated prd.ts</p>
          <div class="flex gap-2">
            <button
              data-copy-btn
              onclick={copyToClipboard}
              class="px-3 py-1.5 text-xs bg-white/10 hover:bg-white/20 text-white rounded transition-colors"
            >
              Copy
            </button>
            <button
              onclick={downloadPrd}
              class="px-3 py-1.5 text-xs bg-amber-500/20 hover:bg-amber-500/30 text-amber-300 rounded transition-colors"
            >
              Download
            </button>
          </div>
        </div>
        <div class="p-4 overflow-x-auto">
          <CodeBlock code={generatedCode} language="typescript" />
        </div>
        <div class="border-t border-white/10 bg-black/40 px-4 py-3">
          <div class="flex flex-wrap items-center justify-between gap-3">
            <div class="flex flex-wrap items-center gap-2">
              <button
                onclick={generateGates}
                class="px-4 py-2 text-xs font-semibold uppercase tracking-widest bg-amber-500/20 hover:bg-amber-500/30 text-amber-200 rounded transition-colors"
              >
                Generate gate files
              </button>
            </div>
            <span class="text-[11px] uppercase tracking-widest text-white/50">
              Step 2: split into gates/
            </span>
          </div>
          {#if gateError}
            <p class="mt-2 text-xs text-red-300">{gateError}</p>
          {/if}
          {#if gateFiles.length > 0}
            <div class="mt-3 grid gap-3">
              {#each gateFiles as file}
                <div class="rounded border border-white/10 bg-black/60">
                  <div class="flex items-center justify-between gap-2 border-b border-white/10 px-3 py-2 text-xs text-white/70">
                    <span class="font-mono">{file.filename}</span>
                    <div class="flex gap-2">
                      <button
                        onclick={() => copyGateFile(file.filename, file.code)}
                        class="rounded border border-white/10 bg-white/10 px-2 py-1 text-[11px] uppercase tracking-widest text-white/70 hover:bg-white/20"
                      >
                        Copy
                      </button>
                      <button
                        onclick={() => downloadGateFile(file.filename, file.code)}
                        class="rounded border border-amber-300/20 bg-amber-500/10 px-2 py-1 text-[11px] uppercase tracking-widest text-amber-200 hover:bg-amber-500/20"
                      >
                        Download
                      </button>
                    </div>
                  </div>
                  <div class="p-3">
                    <CodeBlock code={file.code} language="typescript" />
                  </div>
                </div>
              {/each}
            </div>
          {/if}
        </div>
        <div class="border-t border-white/10 bg-black/40 px-4 py-3">
          <div class="flex flex-wrap items-center justify-between gap-3">
            <div class="flex flex-wrap items-center gap-2">
              <button
                onclick={runInSandbox}
                disabled={running}
                class="px-4 py-2 text-xs font-semibold uppercase tracking-widest bg-white/10 hover:bg-white/20 text-white rounded transition-colors disabled:bg-gray-700 disabled:cursor-not-allowed"
              >
                {#if running}
                  Running in sandbox...
                {:else}
                  Run in sandbox
                {/if}
              </button>
              {#if running}
                <button
                  onclick={cancelRun}
                  class="px-3 py-2 text-xs uppercase tracking-widest text-white/70 border border-white/20 rounded hover:border-white/40"
                >
                  Cancel
                </button>
              {/if}
            </div>
            {#if running}
              <span class="text-[11px] uppercase tracking-widest text-white/50">
                {Math.ceil(elapsedMs / 1000)}s elapsed
              </span>
            {/if}
            <details class="text-xs text-white/70">
              <summary class="cursor-pointer select-none">Run settings</summary>
              <div class="mt-2 grid gap-2 sm:grid-cols-2">
                <label class="flex flex-col gap-1">
                  <span class="text-[11px] uppercase tracking-widest text-white/50">API_URL</span>
                  <input
                    class="w-full rounded border border-white/10 bg-black/40 px-2 py-1 text-xs text-white"
                    bind:value={apiUrl}
                  />
                </label>
                <label class="flex flex-col gap-1">
                  <span class="text-[11px] uppercase tracking-widest text-white/50">TEST_URL</span>
                  <input
                    class="w-full rounded border border-white/10 bg-black/40 px-2 py-1 text-xs text-white"
                    bind:value={testUrl}
                  />
                </label>
              </div>
            </details>
          </div>
          {#if runError}
            <p class="mt-2 text-xs text-red-300">{runError}</p>
          {/if}
          {#if runLogs.length > 0}
            <pre class="mt-3 max-h-64 overflow-auto rounded border border-white/10 bg-black/60 p-3 text-xs text-white/80 whitespace-pre-wrap">{runLogs.join('')}</pre>
          {/if}
        </div>
      </div>
    {/if}
  </div>
</section>
